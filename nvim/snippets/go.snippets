snippet anon "fn := func() { ... }"
	${1:fn} := func() {
		${2:${VISUAL}}
	}
	${0}

snippet ap= "a = append(a, value)"
	${1:slice} = append($1, ${0:value})

snippet cons "const ( ... )"
	const (
		${1:NAME} ${2:Type} = ${3:value}
		${0}
	)

snippet iota "const ( ... = iota )"
	const (
		${1:NAME} ${2:Type} = iota
		${0}
	)

snippet df "defer someFunction()"
	defer ${1:func}(${2})
	${0}

snippet def "defer func() { ... }"
	defer func() {
		${0:${VISUAL}}
	}()

snippet import "import ( ... )"
	import (
		"${1:package}"
	)

snippet interface "interface I { ... }"
	type ${1:Interface} interface {
		${2:/* TODO: add methods */}
	}

snippet if "if ... { ... }"
	if ${1:condition} {
		${0:${VISUAL}}
	}

snippet ife "If with inline error"
	if err := ${1:${VISUAL}}; err != nil {
		${0}
	}

snippet errn "Error return"
	if err != nil {
		return err
	}
	${0}

snippet errn, "Error return with two return values" !b
	if err != nil {
		return ${1:nil}, ${2:err}
	}
	${0}

snippet errh "Error handle and return" !b
	if err != nil {
		${1}
		return
	}
	${0}

snippet fori "for 0..N-1 { ... }"
	for ${1:i} := 0; $1 < ${2:N}; $1++ {
		${0:${VISUAL}}
	}

snippet forr "for k, v := range items { ... }"
	for ${2:k}, ${3:v} := range ${1} {
		${0:${VISUAL}}
	}

snippet forsel "for select"
	for {
		select {
			case ${2:${1:result} := }<- ${3:channel}:
				${0}
		}
	}

snippet func "func Function(...) [error] { ... }"
	func ${1:name}(${2:params}) ${3} {
		${0:${VISUAL}}
	}

snippet ff "fmt.Printf(...)"
	fmt.Printf("$1 = %+v\n", $1)

snippet fn "fmt.Println(...)"
	fmt.Println("${1:${VISUAL}}")

snippet fe "fmt.Errorf(...)"
	fmt.Errorf("${1:${VISUAL}}")

snippet few "fmt.Errorf(%w, err)"
	fmt.Errorf("${1:message}: %w", ${2:${VISUAL:err}})

snippet ln "log.Println(...)"
	log.Println("${1:${VISUAL}}")

snippet main "func main() { ... }"
	func main() {
		${0:${VISUAL}}
	}

snippet meth "func (self Type) Method(...) [error] { ... }"
	func (${1:receiver} ${2:type}) ${3:name}(${4:params}) ${5} {
		${0:${VISUAL}}
	}

snippet ok "if !ok { ... }"
	if !ok {
		${0:${VISUAL}}
	}

snippet st "type T struct { ... }"
	type ${1:Type} struct {
		${0}
	}

snippet switch "switch x { ... }"
	switch ${1:var} {
	case ${2:value1}:
		${0}
	}

snippet sp "fmt.Sprintf(...)"
	fmt.Sprintf("%${1:s}", ${2:var})

snippet gof "go func() { ... }()"
	go func() {
		${1:${VISUAL}}
	}()
	${0}

snippet test "func TestXYZ(t *testing.T) { ... }"
	func Test${1:Function}(t *testing.T) {
		${0:${VISUAL}}
	}

snippet tt
	var tests = []struct {
		name string
	}{
		{"${1}"},
	}
	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T){
			${0}
		})
	}

snippet rne "require.NoError"
	require.NoError(t, err)

snippet hf "http.HandlerFunc"
	func ${1:handler}(w http.ResponseWriter, r *http.Request) {
		${0:fmt.Fprintf(w, "OHAI!")}
	}

snippet rhf "httprouter.HandlerFunc"
	func ${1:handler}(r http.ResponseWriter, r *http.Request, params httprouter.Params) {
		${0:fmt.Fprintf(w, "OHAI!")}
	}

snippet tsrv "httptest.NewServer"
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintln(w, ${1:"ohai"})
	}))
	defer ts.Close()

snippet vars "var ( ... )"
	var (
		${1:x} ${2:Type}${3: = ${0:value}}
	)
